"""
Tools for reading and writing LAMMPS data files and dumps.
"""

import numpy as np
import pandas as pd
import copy


def write_lammps(file_name, lmp_tmp, mode='full'):
    """
    input: file_name,lmp_tmp
    lmp_tmp is a an instance of lammps class with full attributes,
    must contain natoms, natom_types, x, y, z, atom_info, mass, pair_coeff
    optionally contain
    """
    with open('{}'.format(file_name), 'w') as f:
        f.write('Generated by ZYMD\n\n')

        f.write('{} atoms\n'.format(lmp_tmp.natoms))
        f.write('{} atom types\n'.format(lmp_tmp.natom_types))
        f.write('{} bonds\n'.format(lmp_tmp.nbonds))
        f.write('{} bond types\n'.format(lmp_tmp.nbond_types))
        f.write('{} angles\n'.format(lmp_tmp.nangles))
        f.write('{} angle types\n'.format(lmp_tmp.nangle_types))
        f.write('{} dihedrals\n'.format(lmp_tmp.ndihedrals))
        f.write('{} dihedral types\n'.format(lmp_tmp.ndihedral_types))
        f.write('{} impropers\n'.format(lmp_tmp.nimpropers))
        f.write('{} improper types\n'.format(lmp_tmp.nimproper_types))
        f.write('\n')

        f.write('{0:.16f} {1:.16f} xlo xhi\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))
        f.write('{0:.16f} {1:.16f} ylo yhi\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))
        f.write('{0:.16f} {1:.16f} zlo zhi\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))
        f.write('\n')

        f.write('Masses\n\n')
        for i in range(len(lmp_tmp.mass)):
            if lmp_tmp.mass.shape[1] == 3:
                f.write('{0:d} {1:.3f} # {2:s}\n'.format(
                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))
            elif lmp_tmp.mass.shape[1] == 2:
                f.write('{0:d} {1:.3f}\n'.format(
                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))
        f.write('\n')

        if hasattr(lmp_tmp, 'pair_coeff') and not (lmp_tmp.pair_coeff is None):
            f.write('Pair Coeffs\n\n')
            for i in range(len(lmp_tmp.pair_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(
                    int(lmp_tmp.pair_coeff[i, 0]), lmp_tmp.pair_coeff[i, 1], lmp_tmp.pair_coeff[i, 2]))
            f.write('\n')

        if hasattr(lmp_tmp, 'bond_coeff') and not (lmp_tmp.bond_coeff is None):
            f.write('Bond Coeffs\n\n')
            for i in range(len(lmp_tmp.bond_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(
                    int(lmp_tmp.bond_coeff[i, 0]), lmp_tmp.bond_coeff[i, 1], lmp_tmp.bond_coeff[i, 2]))
            f.write('\n')

        if hasattr(lmp_tmp, 'angle_coeff') and not (lmp_tmp.angle_coeff is None):
            f.write('Angle Coeffs\n\n')
            for i in range(len(lmp_tmp.angle_coeff)):
                f.write('{0:d} {1:f} {2:f}\n'.format(
                    int(lmp_tmp.angle_coeff[i, 0]), lmp_tmp.angle_coeff[i, 1], lmp_tmp.angle_coeff[i, 2]))
            f.write('\n')

        if hasattr(lmp_tmp, 'dihedral_coeff') and not (lmp_tmp.dihedral_coeff is None):
            f.write('Dihedral Coeffs\n\n')
            for i in range(len(lmp_tmp.dihedral_coeff)):
                f.write('{0:d} {1:f} {2:f} {3:f} {4:f}\n'.format(int(lmp_tmp.dihedral_coeff[i, 0]), lmp_tmp.dihedral_coeff[i, 1], lmp_tmp.dihedral_coeff[i, 2],
                                                                 lmp_tmp.dihedral_coeff[i, 3], lmp_tmp.dihedral_coeff[i, 4]))
            f.write('\n')

        if hasattr(lmp_tmp, 'improper_coeff') and not (lmp_tmp.improper_coeff is None):
            f.write('Improper Coeffs\n\n')
            for i in range(len(lmp_tmp.improper_coeff)):
                f.write('{0:d} {1:f} {2:d} {3:d}\n'.format(int(lmp_tmp.improper_coeff[i, 0]), lmp_tmp.improper_coeff[i, 1], int(lmp_tmp.improper_coeff[i, 2]),
                                                           int(lmp_tmp.improper_coeff[i, 3])))
            f.write('\n')

        # f.write('Atoms\n\n')
        # for i in range(len(lmp_tmp.atom_info)):
        #     if lmp_tmp.atom_info.shape[1] > 7:
        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f} {8:d} {7:d} {9:d}\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),
        #            lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6], int(lmp_tmp.atom_info[i, 7]), int(lmp_tmp.atom_info[i, 8]), int(lmp_tmp.atom_info[i, 9])))
        #     else:
        #         f.write('{0:d} {1:d} {2:d} {3:f} {4:f} {5:f} {6:f}\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 1]), int(lmp_tmp.atom_info[i, 2]),
        #              lmp_tmp.atom_info[i, 3], lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))
        # f.write('\n')

        f.write('Atoms\n\n')
        lmp_tmp.atom_info = lmp_tmp.atom_info.astype(object)
        lmp_tmp.atom_info[:, 0] = lmp_tmp.atom_info[:, 0].astype(int)
        lmp_tmp.atom_info[:, 1] = lmp_tmp.atom_info[:, 1].astype(int)
        if mode=='full':
            lmp_tmp.atom_info[:, 2] = lmp_tmp.atom_info[:, 2].astype(int)
        for row in lmp_tmp.atom_info:
            line = []
            for val in row:
                if isinstance(val, float) or (isinstance(val, np.float64) or isinstance(val, np.float32)):
                    line.append(f'{val:.6f}')
                else:
                    line.append(f'{int(val)}')
            f.write(' '.join(line) + '\n')
        f.write('\n')

        if hasattr(lmp_tmp, 'velocity_info') and not (lmp_tmp.velocity_info is None):
            f.write('Velocities \n\n')
            for i in range(len(lmp_tmp.velocity_info)):
                f.write('{0:d} {1:f} {2:f} {3:f}\n'.format(int(
                    lmp_tmp.velocity_info[i, 0]), lmp_tmp.velocity_info[i, 1], lmp_tmp.velocity_info[i, 2], lmp_tmp.velocity_info[i, 3]))
            f.write('\n')

        if hasattr(lmp_tmp, 'bond_info') and not (lmp_tmp.bond_info is None) and not (lmp_tmp.nbonds == 0):
            f.write('Bonds\n\n')
            for i in range(len(lmp_tmp.bond_info)):
                f.write('{0:d} {1:d} {2:d} {3:d}\n'.format(int(lmp_tmp.bond_info[i, 0]), int(
                    lmp_tmp.bond_info[i, 1]), int(lmp_tmp.bond_info[i, 2]), int(lmp_tmp.bond_info[i, 3])))
            f.write('\n')

        if hasattr(lmp_tmp, 'angle_info') and not (lmp_tmp.angle_info is None) and not (lmp_tmp.nangles == 0):
            f.write('Angles\n\n')
            for i in range(len(lmp_tmp.angle_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d}\n'.format(int(lmp_tmp.angle_info[i, 0]), int(lmp_tmp.angle_info[i, 1]), int(lmp_tmp.angle_info[i, 2]),
                                                                 int(lmp_tmp.angle_info[i, 3]), int(lmp_tmp.angle_info[i, 4])))
            f.write('\n')

        if hasattr(lmp_tmp, 'dihedral_info') and not (lmp_tmp.dihedral_info is None) and not (lmp_tmp.ndihedrals == 0):
            f.write('Dihedrals\n\n')
            for i in range(len(lmp_tmp.dihedral_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\n'.format(int(lmp_tmp.dihedral_info[i, 0]), int(lmp_tmp.dihedral_info[i, 1]), int(lmp_tmp.dihedral_info[i, 2]),
                                                                       int(lmp_tmp.dihedral_info[i, 3]), int(lmp_tmp.dihedral_info[i, 4]), int(lmp_tmp.dihedral_info[i, 5])))
            f.write('\n')

        if hasattr(lmp_tmp, 'improper_info') and not (lmp_tmp.improper_info is None) and not (lmp_tmp.nimpropers == 0):
            f.write('Impropers\n\n')
            for i in range(len(lmp_tmp.improper_info)):
                f.write('{0:d} {1:d} {2:d} {3:d} {4:d} {5:d}\n'.format(int(lmp_tmp.improper_info[i, 0]), int(lmp_tmp.improper_info[i, 1]), int(lmp_tmp.improper_info[i, 2]),
                                                                       int(lmp_tmp.improper_info[i, 3]), int(lmp_tmp.improper_info[i, 4]), int(lmp_tmp.improper_info[i, 5])))
            f.write('\n')


def write_lammps_atomic(file_name, lmp_tmp):
    """
    input: file_name,lmp_tmp
    lmp_tmp is a class of lammps with atomic attributes,
    """
    with open('{}'.format(file_name), 'w') as f:
        f.write('Generated by ZY code\n\n')

        f.write('{} atoms\n'.format(lmp_tmp.natoms))
        f.write('{} atom types\n'.format(lmp_tmp.natom_types))
        f.write('\n')

        f.write('{0:.16f} {1:.16f} xlo xhi\n'.format(lmp_tmp.x[0], lmp_tmp.x[1]))
        f.write('{0:.16f} {1:.16f} ylo yhi\n'.format(lmp_tmp.y[0], lmp_tmp.y[1]))
        f.write('{0:.16f} {1:.16f} zlo zhi\n'.format(lmp_tmp.z[0], lmp_tmp.z[1]))
        f.write('\n')

        f.write('Masses\n\n')
        for i in range(len(lmp_tmp.mass)):
            if lmp_tmp.mass.shape[1] == 3:
                f.write('{0:d} {1:.3f} # {2:s}\n'.format(
                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1]), lmp_tmp.mass[i, 2]))
            elif lmp_tmp.mass.shape[1] == 2:
                f.write('{0:d} {1:.3f}\n'.format(
                    int(float(lmp_tmp.mass[i, 0])), float(lmp_tmp.mass[i, 1])))
        f.write('\n')

        f.write('Atoms # full\n\n')
        for i in range(len(lmp_tmp.atom_info)):
            if lmp_tmp.atom_info.shape[1] > 7:
                f.write('{0:d} {1:d} {2:f} {3:f} {4:f}\n'.format(int(lmp_tmp.atom_info[i, 0]), int(lmp_tmp.atom_info[i, 2]), lmp_tmp.atom_info[i, 4], lmp_tmp.atom_info[i, 5], lmp_tmp.atom_info[i, 6]))
        f.write('\n')


class lammps:
    def __init__(self, natoms=0, natom_types=0, x=[0, 0], y=[0, 0], z=[0, 0], mass=[], atom_info=[], nbonds=0, nangles=0, ndihedrals=0, nimpropers=0, nbond_types=0, nangle_types=0, ndihedral_types=0, nimproper_types=0, pair_coeff=None, bond_coeff=None, angle_coeff=None, dihedral_coeff=None, improper_coeff=None, velocity_info=None, bond_info=[], angle_info=[], dihedral_info=[], improper_info=[], mode='full'):
        self.natoms = natoms
        self.nbonds = nbonds
        self.nangles = nangles
        self.ndihedrals = ndihedrals
        self.nimpropers = nimpropers

        self.natom_types = natom_types
        self.nbond_types = nbond_types
        self.nangle_types = nangle_types
        self.ndihedral_types = ndihedral_types
        self.nimproper_types = nimproper_types

        self.x = x
        self.y = y
        self.z = z

        self.mass = mass
        self.pair_coeff = pair_coeff
        self.bond_coeff = bond_coeff
        self.angle_coeff = angle_coeff
        self.dihedral_coeff = dihedral_coeff
        self.improper_coeff = improper_coeff

        self.atom_info = atom_info
        self.velocity_info = velocity_info
        self.bond_info = bond_info
        self.angle_info = angle_info
        self.dihedral_info = dihedral_info
        self.improper_info = improper_info

        self.mode = mode

    def copy(self):
        return copy.deepcopy(self)

    def write(self, file_name):
        write_lammps(file_name, self, mode=self.mode)


def distance_pbc(coord1, coord2, box):
    """
    Calculate the pairwise distances between sets of atoms in a box with periodic boundary conditions.

    Parameters:
    - coord1 (np.ndarray): A (N x 3) array of coordinates for N atoms.
    - coord2 (np.ndarray): A (M x 3) array of coordinates for M atoms.
    - box (np.ndarray): A (3 x 3) array representing the box vectors.

    Returns:
    - dist_matrix (np.ndarray): An (N x M) matrix of distances.
    """
    # Expand coord1 and coord2 to (N, 1, 3) and (1, M, 3) respectively to broadcast subtraction
    delta = coord1[:, np.newaxis, :] - coord2[np.newaxis, :, :]

    # Compute box inversions and apply periodic boundary conditions
    delta -= np.round(delta @ np.linalg.inv(box)) @ box

    # Compute the Euclidean distance
    dist_matrix = np.linalg.norm(delta, axis=-1)

    return dist_matrix


def read_lammps_full(file):

    f = open(file, 'r')
    L = f.readlines()
    f.close()

    isxyxzyz = 0
    for iline in range(len(L)):
        if 'atoms' in L[iline]:
            natoms = int(L[iline].split()[0])

        if 'atom types' in L[iline]:
            natom_types = int(L[iline].split()[0])

        if 'xlo' in L[iline]:
            xlo = float(L[iline].split()[0])
            xhi = float(L[iline].split()[1])
        if 'ylo' in L[iline]:
            ylo = float(L[iline].split()[0])
            yhi = float(L[iline].split()[1])
        if 'zlo' in L[iline]:
            zlo = float(L[iline].split()[0])
            zhi = float(L[iline].split()[1])
        if 'Masses' in L[iline]:
            lmass = iline+2
            mass = []
            for ia in range(natom_types):
                mass.append(L[lmass+ia].split())
            mass = np.vstack(mass)
        if 'Atoms' in L[iline]:
            lia = iline+2
            atom_info = []
            for ia in range(natoms):
                atom_info.append(L[lia+ia].split())
            atom_info = np.vstack(atom_info).astype(float)
            atom_info[:, 0] = atom_info[:, 0].astype(int)
            atom_info[:, 1] = atom_info[:, 1].astype(int)


    result = lammps(natoms, natom_types, [xlo, xhi], [ylo, yhi], [zlo, zhi], mass, atom_info)

    for iline in range(len(L)):
        if 'bonds' in L[iline]:
            result.nbonds = int(L[iline].split()[0])
        if 'angles' in L[iline]:
            result.nangles = int(L[iline].split()[0])
        if 'dihedrals' in L[iline]:
            result.ndihedrals = int(L[iline].split()[0])
        if 'impropers' in L[iline]:
            result.nimpropers = int(L[iline].split()[0])

        if 'bond types' in L[iline]:
            result.nbond_types = int(L[iline].split()[0])
        if 'angle types' in L[iline]:
            result.nangle_types = int(L[iline].split()[0])
        if 'dihedral types' in L[iline]:
            result.ndihedral_types = int(L[iline].split()[0])
        if 'improper types' in L[iline]:
            result.nimproper_types = int(L[iline].split()[0])

        if 'xy' in L[iline]:
            isxyxzyz = 1
            result.xy = float(L[iline].split()[0])
            result.xz = float(L[iline].split()[1])
            result.yz = float(L[iline].split()[2])

        ############ potential coeff ##############
        if 'Pair Coeffs' in L[iline]:
            lpc = iline+2
            pc = []
            for ia in range(natom_types):
                pc.append(L[lpc+ia].split())
            result.pair_coeff = np.vstack(pc).astype(float)

        if 'Bond Coeffs' in L[iline]:
            lbc = iline+2
            bc = []
            for ia in range(result.nbond_types):
                bc.append(L[lbc+ia].split())
            result.bond_coeff = np.vstack(bc).astype(float)

        if 'Angle Coeffs' in L[iline]:
            lac = iline+2
            ac = []
            for ia in range(result.nangle_types):
                ac.append(L[lac+ia].split())
            result.angle_coeff = np.vstack(ac).astype(float)

        if 'Dihedral Coeffs' in L[iline]:
            ldc = iline+2
            dc = []
            for ia in range(result.ndihedral_types):
                dc.append(L[ldc+ia].split())
            result.dihedral_coeff = np.vstack(dc).astype(float)

        if 'Improper Coeffs' in L[iline]:
            lic = iline+2
            ic = []
            for ia in range(result.nimproper_types):
                ic.append(L[lic+ia].split())
            result.improper_coeff = np.vstack(ic).astype(float)

        ########### atoms ################

        if 'Velocities' in L[iline]:
            liv = iline+2
            velocity_info = []
            for ia in range(natoms):
                velocity_info.append(L[liv+ia].split())
            result.velocity_info = np.vstack(velocity_info).astype(float)

    #     ########## topology ##############
        if 'Bonds' in L[iline]:
            lib = iline+2
            bond_info = []
            for ia in range(result.nbonds):
                bond_info.append(L[lib+ia].split())
            result.bond_info = np.vstack(bond_info).astype(float)

        if 'Angles' in L[iline]:
            lian = iline+2
            angle_info = []
            for ia in range(result.nangles):
                angle_info.append(L[lian+ia].split())
            result.angle_info = np.vstack(angle_info).astype(float)

        if 'Dihedrals' in L[iline]:
            lidi = iline+2
            dihedral_info = []
            for ia in range(result.ndihedrals):
                dihedral_info.append(L[lidi+ia].split())
            result.dihedral_info = np.vstack(dihedral_info).astype(float)

        if 'Impropers' in L[iline]:
            liim = iline+2
            impropers_info = []
            for ia in range(result.nimpropers):
                impropers_info.append(L[liim+ia].split())
            result.improper_info = np.vstack(impropers_info).astype(float)

    if isxyxzyz == 0:
        xy = 0
        xz = 0
        yz = 0
        box = np.array([[xhi-xlo, 0, 0], [xy, yhi-ylo, 0], [xz, yz, zhi-zlo]])
        shift = xlo

    return result


def read_lammps_dump_custom(dump_file, interval=1):
    """
    input: dump_file
    output: frame, t_list, L_list
    """
    t_list = []
    frame = []
    L_list = []
    frame_count = 0

    with open(dump_file, 'r') as f:
        for line in f:
            if line.startswith('ITEM: TIMESTEP'):
                frame_count += 1
                timestep = int(next(f).split()[0])

                # Only process and store the frame if frame_count is a multiple of the interval
                if frame_count % interval == 0:
                    t_list.append(timestep)
                    store_frame = True
                else:
                    store_frame = False

            if line.startswith('ITEM: NUMBER OF ATOMS') and store_frame:
                natoms = int(next(f).split()[0])

            if line.startswith('ITEM: BOX') and store_frame:
                lx = [float(x) for x in next(f).split()[:2]]
                ly = [float(x) for x in next(f).split()[:2]]
                lz = [float(x) for x in next(f).split()[:2]]
                L_list.append([lx, ly, lz])

            if line.startswith('ITEM: ATOMS') and store_frame:
                columns = line.split()[2:]
                data = []
                for i in range(natoms):
                    line_data = []
                    raw_fields = [x for x in next(f).split() if x.strip()]
                    for x in raw_fields[:len(columns)]:
                        try:
                            line_data.append(float(x))
                        except ValueError:
                            line_data.append(str(x))
                    data.append(line_data)
                    # data.append([float(x) for x in next(f).split()])
                df = pd.DataFrame(data, columns=columns)
                df_sorted = df.sort_values(by=['id'])
                frame.append(df_sorted)

    return frame, t_list, L_list


def write_lammps_dump_custom(file_name, frame, t_list, L_list):
    """
    input: file_name, frame, t_list, L_list
    output: write the frame, t_list, L_list to file_name
    """
    f = open('{}'.format(file_name), 'w')
    for it in range(len(t_list)):
        f.write('ITEM: TIMESTEP\n')
        f.write('{}\n'.format(t_list[it]))
        f.write('ITEM: NUMBER OF ATOMS\n')
        f.write('{}\n'.format(len(frame[it])))
        f.write('ITEM: BOX BOUNDS pp pp pp\n')
        for i in range(3):
            f.write('{} {}\n'.format(L_list[it][i][0], L_list[it][i][1]))
        f.write('ITEM: ATOMS ')
        for col in frame[it].columns:
            f.write('{} '.format(col))
        f.write('\n')
        for i in range(len(frame[it])):
            f.write('{} '.format(int(frame[it].iloc[i, 0])))
            for j in range(1, len(frame[it].columns)):
                # if integer, write as int, otherwise as float
                if isinstance(frame[it].iloc[i, j], int):
                    f.write('{0:d} '.format(int(frame[it].iloc[i, j])))
                else:
                    f.write('{0:.6f} '.format(frame[it].iloc[i, j]))
            f.write('\n')
    f.close()


def compute_mappings(file_lmp, file_key):

    lmp = read_lammps_full(file_lmp)
    tmp = pd.read_table(file_key,
                        header=None, sep='\s+', skiprows=31, nrows=lmp.natoms)

    mapping = np.zeros([lmp.natoms, 2])
    mapping[:, 0] = np.arange(lmp.natoms)+1
    # modify the types given by Ligpargen
    unique_type = np.unique(tmp.iloc[:, 3])
    print(unique_type)
    for i, type in enumerate(unique_type):
        mapping[tmp.iloc[:, 3] == type, 1] = i+1

    mass_new = lmp.mass.copy()
    mass_new[:, 0] = mapping[:, 1]
    mass_new = np.unique(mass_new, axis=0)

    mass_to_element = {
        '1.008': 'H',
        '12.011': 'C',
        '14.007': 'N',
        '15.999': 'O',
    }

    # Function to get element name from mass
    def get_element_name(mass):
        rounded_mass = f"{float(mass):.3f}"
        return mass_to_element.get(rounded_mass, "Unknown")
    element_names = np.array([get_element_name(mass) for mass in mass_new[:, 1]])
    mass_new = np.column_stack((mass_new, element_names))

    pair_coeff_new = lmp.pair_coeff.copy()
    pair_coeff_new[:, 0] = mapping[:, 1]
    pair_coeff_new = np.unique(pair_coeff_new, axis=0)

    atom_info_new = lmp.atom_info.copy()
    atom_info_new[:, 2] = mapping[:, 1]

    ### bonds ####
    bond_info_new = lmp.bond_info.copy()
    for i in range(lmp.natoms):
        bond_info_new[lmp.bond_info[:, 2] == i+1, 2] = mapping[i, 1]
        bond_info_new[lmp.bond_info[:, 3] == i+1, 3] = mapping[i, 1]

    for i in range(len(bond_info_new)):
        if bond_info_new[i, 2] > bond_info_new[i, 3]:
            tmp = bond_info_new[i, 3]
            bond_info_new[i, 3] = bond_info_new[i, 2]
            bond_info_new[i, 2] = tmp

    nbond_types_new = len(np.unique(bond_info_new[:, 2:], axis=0))

    mapping_bonds = np.unique(bond_info_new[:, 2:], axis=0)
    # print(nbond_types_new,mapping_bonds)

    for i in range(nbond_types_new):
        idx_tmp = np.argwhere((bond_info_new[:, 2] == mapping_bonds[i, 0]) & (
            bond_info_new[:, 3] == mapping_bonds[i, 1]))
        bond_info_new[idx_tmp, 1] = i+1

    bond_info_new[:, 2:] = lmp.bond_info[:, 2:]

    bond_coeff_new = lmp.bond_coeff.copy()
    bond_coeff_new[:, 0] = bond_info_new[:, 1]
    bond_coeff_new = np.unique(bond_coeff_new, axis=0)

    ### angles ####
    angle_info_new = lmp.angle_info.copy()
    for i in range(lmp.natoms):
        angle_info_new[lmp.angle_info[:, 2] == i+1, 2] = mapping[i, 1]
        angle_info_new[lmp.angle_info[:, 3] == i+1, 3] = mapping[i, 1]
        angle_info_new[lmp.angle_info[:, 4] == i+1, 4] = mapping[i, 1]

    for i in range(len(angle_info_new)):
        if angle_info_new[i, 2] > angle_info_new[i, 4]:
            tmp = angle_info_new[i, 4]
            angle_info_new[i, 4] = angle_info_new[i, 2]
            angle_info_new[i, 2] = tmp

    nangle_types_new = len(np.unique(angle_info_new[:, 2:], axis=0))

    mapping_angles = np.unique(angle_info_new[:, 2:], axis=0)
    # print('new angles', nangle_types_new, mapping_angles)

    for i in range(nangle_types_new):
        idx_tmp = np.argwhere((angle_info_new[:, 2] == mapping_angles[i, 0]) & (angle_info_new[:, 3] == mapping_angles[i, 1])
                              & (angle_info_new[:, 4] == mapping_angles[i, 2]))
        angle_info_new[idx_tmp, 1] = i+1

    angle_info_new[:, 2:] = lmp.angle_info[:, 2:]

    angle_coeff_new = lmp.angle_coeff.copy()
    angle_coeff_new[:, 0] = angle_info_new[:, 1]
    angle_coeff_new = np.unique(angle_coeff_new, axis=0)

    ### Dihedrals ####
    dihedral_info_new = lmp.dihedral_info.copy()
    for i in range(lmp.natoms):
        dihedral_info_new[lmp.dihedral_info[:, 2] == i+1, 2] = mapping[i, 1]
        dihedral_info_new[lmp.dihedral_info[:, 3] == i+1, 3] = mapping[i, 1]
        dihedral_info_new[lmp.dihedral_info[:, 4] == i+1, 4] = mapping[i, 1]
        dihedral_info_new[lmp.dihedral_info[:, 5] == i+1, 5] = mapping[i, 1]

    for i in range(len(dihedral_info_new)):
        if dihedral_info_new[i, 2] > dihedral_info_new[i, 5]:
            tmp1 = dihedral_info_new[i, 5]
            tmp2 = dihedral_info_new[i, 4]
            dihedral_info_new[i, 5] = dihedral_info_new[i, 2]
            dihedral_info_new[i, 4] = dihedral_info_new[i, 3]
            dihedral_info_new[i, 2] = tmp1
            dihedral_info_new[i, 3] = tmp2

    ndihedral_types_new = len(np.unique(dihedral_info_new[:, 2:], axis=0))
    mapping_dihedrals = np.unique(dihedral_info_new[:, 2:], axis=0)
    # print('dihedrals',mapping_dihedrals)

    for i in range(ndihedral_types_new):
        idx_tmp = np.argwhere((dihedral_info_new[:, 2] == mapping_dihedrals[i, 0]) & (dihedral_info_new[:, 3] == mapping_dihedrals[i, 1])
                              & (dihedral_info_new[:, 4] == mapping_dihedrals[i, 2]) & (dihedral_info_new[:, 5] == mapping_dihedrals[i, 3]))
        dihedral_info_new[idx_tmp, 1] = i+1

    dihedral_info_new[:, 2:] = lmp.dihedral_info[:, 2:]

    dihedral_coeff_new = lmp.dihedral_coeff.copy()
    dihedral_coeff_new[:, 0] = dihedral_info_new[:, 1]
    dihedral_coeff_new = np.unique(dihedral_coeff_new, axis=0)

    ### impropers ####
    impropers_info_new = lmp.improper_info.copy()
    for i in range(lmp.natoms):
        impropers_info_new[lmp.improper_info[:, 2] == i+1, 2] = mapping[i, 1]
        impropers_info_new[lmp.improper_info[:, 3] == i+1, 3] = mapping[i, 1]
        impropers_info_new[lmp.improper_info[:, 4] == i+1, 4] = mapping[i, 1]
        impropers_info_new[lmp.improper_info[:, 5] == i+1, 5] = mapping[i, 1]

    for i in range(len(dihedral_info_new)):
        impropers_info_new[:, 3:] = np.sort(impropers_info_new[:, 3:])

    nimproper_types_new = len(np.unique(impropers_info_new[:, 2:], axis=0))

    mapping_impropers = np.unique(impropers_info_new[:, 2:], axis=0)
    # print('improper',nimproper_types_new,mapping_impropers)

    for i in range(nimproper_types_new):
        idx_tmp = np.argwhere((impropers_info_new[:, 2] == mapping_impropers[i, 0]) & (impropers_info_new[:, 3] == mapping_impropers[i, 1])
                              & (impropers_info_new[:, 4] == mapping_impropers[i, 2]) & (impropers_info_new[:, 5] == mapping_impropers[i, 3]))
        impropers_info_new[idx_tmp, 1] = i+1

    impropers_info_new[:, 2:] = lmp.improper_info[:, 2:]

    improper_coeff_new = lmp.improper_coeff.copy()
    improper_coeff_new[:, 0] = impropers_info_new[:, 1]
    improper_coeff_new = np.unique(improper_coeff_new, axis=0)

    # lmp_new = lammps(natoms=lmp.natoms,
    #                     natom_types=len(mass_new),
    #                     nbonds=lmp.nbonds,
    #                     nbond_types=nbond_types_new,
    #                     nangles=lmp.nangles,
    #                     nangle_types=nangle_types_new,
    #                     ndihedrals=lmp.ndihedrals,
    #                     ndihedral_types=ndihedral_types_new,
    #                     nimpropers=lmp.nimpropers,
    #                     nimproper_types=nimproper_types_new,
    #                     mass=mass_new,
    #                     x=lmp.x,
    #                     y=lmp.y,
    #                     z=lmp.z,
    #                     pair_coeff=pair_coeff_new,
    #                     bond_coeff=bond_coeff_new,
    #                     angle_coeff=angle_coeff_new,
    #                     dihedral_coeff=dihedral_coeff_new,
    #                     improper_coeff=improper_coeff_new,
    #                     atom_info=atom_info_new,
    #                     bond_info=bond_info_new,
    #                     angle_info=angle_info_new,
    #                     dihedral_info=dihedral_info_new,
    #                     improper_info=impropers_info_new)
    mapping_dict = {'mapping_bonds': mapping_bonds,
                    'mapping_angles': mapping_angles,
                    'mapping_dihedrals': mapping_dihedrals,
                    'mapping_impropers': mapping_impropers,
                    'mass_new': mass_new,
                    'unique_type': unique_type,
                    'pair_coeff_new': pair_coeff_new,
                    'bond_coeff_new': bond_coeff_new,
                    'angle_coeff_new': angle_coeff_new,
                    'dihedral_coeff_new': dihedral_coeff_new,
                    'improper_coeff_new': improper_coeff_new}
    return mapping_dict


def convert_lmp(file_lmp, file_key, mapping_dict):

    lmp_react1 = read_lammps_full(file_lmp)
    tmp = pd.read_table(file_key,
                        header=None, sep='\s+', skiprows=31, nrows=lmp_react1.natoms)

    mapping = np.zeros([lmp_react1.natoms, 2])
    mapping[:, 0] = np.arange(lmp_react1.natoms)+1
    # modify the types given by Ligpargen

    for i, type in enumerate(mapping_dict['unique_type']):
        mapping[tmp.iloc[:, 3] == type, 1] = i+1

    # natom_types_new = len(mapping_dict['mass_new'])
    atom_info_new = lmp_react1.atom_info.copy()
    atom_info_new[:, 2] = mapping[:, 1]

    ### bonds ####
    bond_info_new = lmp_react1.bond_info.copy()
    for i in range(lmp_react1.natoms):
        bond_info_new[lmp_react1.bond_info[:, 2] == i+1, 2] = mapping[i, 1]
        bond_info_new[lmp_react1.bond_info[:, 3] == i+1, 3] = mapping[i, 1]

    for i in range(len(bond_info_new)):
        if bond_info_new[i, 2] > bond_info_new[i, 3]:
            tmp = bond_info_new[i, 3]
            bond_info_new[i, 3] = bond_info_new[i, 2]
            bond_info_new[i, 2] = tmp

    for i in range(len(bond_info_new)):
        bond_info_new[i, 1] = 0
        for j in range(len(mapping_dict['mapping_bonds'])):
            if ((bond_info_new[i, 2] == mapping_dict['mapping_bonds'][j, 0]) and (bond_info_new[i, 3] == mapping_dict['mapping_bonds'][j, 1])):
                bond_info_new[i, 2] = lmp_react1.bond_info[i, 2]
                bond_info_new[i, 3] = lmp_react1.bond_info[i, 3]
                bond_info_new[i, 1] = j+1
    print(np.sum(bond_info_new[:, 1] == 0))

    # nangle_types_new = len(mapping_dict['angle_coeff_new'])
    ### angles ####
    angle_info_new = lmp_react1.angle_info.copy()
    for i in range(lmp_react1.natoms):
        angle_info_new[lmp_react1.angle_info[:, 2] == i+1, 2] = mapping[i, 1]
        angle_info_new[lmp_react1.angle_info[:, 3] == i+1, 3] = mapping[i, 1]
        angle_info_new[lmp_react1.angle_info[:, 4] == i+1, 4] = mapping[i, 1]

    for i in range(len(angle_info_new)):
        if angle_info_new[i, 2] > angle_info_new[i, 4]:
            tmp = angle_info_new[i, 4]
            angle_info_new[i, 4] = angle_info_new[i, 2]
            angle_info_new[i, 2] = tmp

    for i in range(len(angle_info_new)):
        angle_info_new[i, 1] = 0
        match = 0
        for j in range(len(mapping_dict['mapping_angles'])):
            if (angle_info_new[i, 3] == mapping_dict['mapping_angles'][j, 1]) and ((angle_info_new[i, 2] == mapping_dict['mapping_angles'][j, 0]) and (angle_info_new[i, 4] == mapping_dict['mapping_angles'][j, 2])):
                angle_info_new[i, 2] = lmp_react1.angle_info[i, 2]
                angle_info_new[i, 3] = lmp_react1.angle_info[i, 3]
                angle_info_new[i, 4] = lmp_react1.angle_info[i, 4]
                angle_info_new[i, 1] = j+1
                match += 1
        if match == 0:
            print(angle_info_new[i])
    print(np.sum(angle_info_new[:, 1] == 0))
    ### dihedrals ####
    dihedral_info_new = lmp_react1.dihedral_info.copy()
    for i in range(lmp_react1.natoms):
        dihedral_info_new[lmp_react1.dihedral_info[:, 2] == i+1, 2] = mapping[i, 1]
        dihedral_info_new[lmp_react1.dihedral_info[:, 3] == i+1, 3] = mapping[i, 1]
        dihedral_info_new[lmp_react1.dihedral_info[:, 4] == i+1, 4] = mapping[i, 1]
        dihedral_info_new[lmp_react1.dihedral_info[:, 5] == i+1, 5] = mapping[i, 1]

    for i in range(len(dihedral_info_new)):
        dihedral_info_new[i, 1] = 0
        match = 0
        for j in range(len(mapping_dict['mapping_dihedrals'])):
            if ((dihedral_info_new[i, 2] == mapping_dict['mapping_dihedrals'][j, 0]) and (dihedral_info_new[i, 3] == mapping_dict['mapping_dihedrals'][j, 1]) and (dihedral_info_new[i, 4] == mapping_dict['mapping_dihedrals'][j, 2]) and (dihedral_info_new[i, 5] == mapping_dict['mapping_dihedrals'][j, 3])) or ((dihedral_info_new[i, 2] == mapping_dict['mapping_dihedrals'][j, 3]) and (dihedral_info_new[i, 3] == mapping_dict['mapping_dihedrals'][j, 2])
                                                                                                                                                                                                                                                                                                                     and (dihedral_info_new[i, 4] == mapping_dict['mapping_dihedrals'][j, 1]) and (dihedral_info_new[i, 5] == mapping_dict['mapping_dihedrals'][j, 0])):
                dihedral_info_new[i, 2] = lmp_react1.dihedral_info[i, 2]
                dihedral_info_new[i, 3] = lmp_react1.dihedral_info[i, 3]
                dihedral_info_new[i, 4] = lmp_react1.dihedral_info[i, 4]
                dihedral_info_new[i, 5] = lmp_react1.dihedral_info[i, 5]
                dihedral_info_new[i, 1] = j+1
                match += 1
        if match == 0:
            dihedral_info_new[i, 2] = lmp_react1.dihedral_info[i, 2]
            dihedral_info_new[i, 3] = lmp_react1.dihedral_info[i, 3]
            dihedral_info_new[i, 4] = lmp_react1.dihedral_info[i, 4]
            dihedral_info_new[i, 5] = lmp_react1.dihedral_info[i, 5]
            dihedral_info_new[i, 1] = mapping_dict['dihedral_coeff_new'][np.sum(
                mapping_dict['dihedral_coeff_new'][:, 1:], axis=1) == 0, 0][0]
            print(dihedral_info_new[i])

    dihedral_info_new = np.delete(dihedral_info_new, np.squeeze(
        np.argwhere(dihedral_info_new[:, 1] == 0)), 0)
    ndihedrals = len(dihedral_info_new)
    dihedral_info_new[:, 0] = np.arange(1, ndihedrals+1)

    print(np.sum(dihedral_info_new[:, 1] == 0))

    nimproper_types_new = len(mapping_dict['improper_coeff_new'])
    ### impropers ####
    impropers_info_new = lmp_react1.improper_info.copy()
    for i in range(lmp_react1.natoms):
        impropers_info_new[lmp_react1.improper_info[:, 2] == i+1, 2] = mapping[i, 1]
        impropers_info_new[lmp_react1.improper_info[:, 3] == i+1, 3] = mapping[i, 1]
        impropers_info_new[lmp_react1.improper_info[:, 4] == i+1, 4] = mapping[i, 1]
        impropers_info_new[lmp_react1.improper_info[:, 5] == i+1, 5] = mapping[i, 1]

    for i in range(len(impropers_info_new)):
        impropers_info_new[i, 1] = 0
        match = 0
        for j in range(len(mapping_dict['mapping_impropers'])):
            if (impropers_info_new[i, 2] == mapping_dict['mapping_impropers'][j, 0]) and np.all(np.sort(impropers_info_new[i, 3:]) == np.sort(mapping_dict['mapping_impropers'][j, 1:])):
                impropers_info_new[i, 2] = lmp_react1.improper_info[i, 2]
                impropers_info_new[i, 3] = lmp_react1.improper_info[i, 3]
                impropers_info_new[i, 4] = lmp_react1.improper_info[i, 4]
                impropers_info_new[i, 5] = lmp_react1.improper_info[i, 5]
                impropers_info_new[i, 1] = j+1
                match += 1
        if match == 0:
            impropers_info_new[i, 2] = lmp_react1.improper_info[i, 2]
            impropers_info_new[i, 3] = lmp_react1.improper_info[i, 3]
            impropers_info_new[i, 4] = lmp_react1.improper_info[i, 4]
            impropers_info_new[i, 5] = lmp_react1.improper_info[i, 5]
            impropers_info_new[i, 1] = mapping_dict['improper_coeff_new'][mapping_dict['improper_coeff_new'][:, 1] == 0, 0][0]
            print(impropers_info_new[i])

    print(np.sum(impropers_info_new[:, 1] == 0))

    lmp_react_new = lammps(natoms=lmp_react1.natoms,
                           natom_types=len(mapping_dict['mass_new']),
                           nbonds=lmp_react1.nbonds,
                           nbond_types=len(mapping_dict['bond_coeff_new']),
                           nangles=lmp_react1.nangles,
                           nangle_types=len(mapping_dict['angle_coeff_new']),
                           ndihedrals=lmp_react1.ndihedrals,
                           ndihedral_types=len(mapping_dict['dihedral_coeff_new']),
                           nimpropers=lmp_react1.nimpropers,
                           nimproper_types=len(mapping_dict['improper_coeff_new']),
                           mass=mapping_dict['mass_new'],
                           x=lmp_react1.x,
                           y=lmp_react1.y,
                           z=lmp_react1.z,
                           pair_coeff=mapping_dict['pair_coeff_new'],
                           bond_coeff=mapping_dict['bond_coeff_new'],
                           angle_coeff=mapping_dict['angle_coeff_new'],
                           dihedral_coeff=mapping_dict['dihedral_coeff_new'],
                           improper_coeff=mapping_dict['improper_coeff_new'],
                           atom_info=atom_info_new,
                           bond_info=bond_info_new,
                           angle_info=angle_info_new,
                           dihedral_info=dihedral_info_new,
                           improper_info=impropers_info_new)
    return lmp_react_new


def write_template(file_lmp, file_template, idx_select, mapping_dict):

    lmp = read_lammps_full(file_lmp)

    natoms_select = len(idx_select)

    mapping = np.zeros([natoms_select, 2])
    mapping[:, 0] = idx_select
    mapping[:, 1] = np.arange(1, natoms_select+1)

    # natom_types
    atom_type_select = np.empty([natoms_select, 2])
    atom_type_select[:, 0] = np.arange(1, natoms_select+1)
    atom_type_select[:, 1] = lmp.atom_info[np.argsort(lmp.atom_info[:, 0]), 2][idx_select-1]

    charge_select = np.empty([natoms_select, 2])
    charge_select[:, 0] = np.arange(1, natoms_select+1)
    charge_select[:, 1] = lmp.atom_info[np.argsort(lmp.atom_info[:, 0]), 3][idx_select-1]

    coors_select = np.empty([natoms_select, 4])
    coors_select[:, 0] = np.arange(1, natoms_select+1)
    coors_select[:, 1:] = lmp.atom_info[np.argsort(lmp.atom_info[:, 0]), 4:7][idx_select-1]

    bond_info_new = []
    j = 0
    for i in range(len(lmp.bond_info)):
        if (lmp.bond_info[i, 2] in idx_select) and (lmp.bond_info[i, 3] in idx_select):
            j += 1
            bond_info_new.append([j, lmp.bond_info[i, 1], mapping[mapping[:, 0] ==
                                 lmp.bond_info[i, 2], 1][0], mapping[mapping[:, 0] == lmp.bond_info[i, 3], 1][0]])
    bond_info_new = np.vstack(bond_info_new)

    nbond_type_new = len(mapping_dict['bond_coeff_new'])
    nbonds_select = len(bond_info_new)

    # angles
    angle_info_new = []
    j = 0
    for i in range(len(lmp.angle_info)):
        if (lmp.angle_info[i, 2] in idx_select) and (lmp.angle_info[i, 3] in idx_select) and (lmp.angle_info[i, 4] in idx_select):
            j += 1
            angle_info_new.append([j, lmp.angle_info[i, 1], mapping[mapping[:, 0] == lmp.angle_info[i, 2], 1][0], mapping[mapping[:, 0] == lmp.angle_info[i, 3], 1][0],
                                   mapping[mapping[:, 0] == lmp.angle_info[i, 4], 1][0]])
    angle_info_new = np.vstack(angle_info_new)

    nangle_type_new = len(mapping_dict['angle_coeff_new'])
    nangles_select = len(angle_info_new)

    # dihedrals
    dihedral_info_new = []

    j = 0
    for i in range(len(lmp.dihedral_info)):
        if (lmp.dihedral_info[i, 2] in idx_select) and (lmp.dihedral_info[i, 3] in idx_select) and (lmp.dihedral_info[i, 4] in idx_select) and (lmp.dihedral_info[i, 5] in idx_select):
            j += 1
            dihedral_info_new.append([j, lmp.dihedral_info[i, 1], mapping[mapping[:, 0] == lmp.dihedral_info[i, 2], 1][0], mapping[mapping[:, 0] == lmp.dihedral_info[i, 3], 1][0],
                                      mapping[mapping[:, 0] == lmp.dihedral_info[i, 4], 1][0], mapping[mapping[:, 0] == lmp.dihedral_info[i, 5], 1][0]])

    dihedral_info_new = np.vstack(dihedral_info_new)

    ndihedral_type_new = len(mapping_dict['dihedral_coeff_new'])
    ndihedrals_select = len(dihedral_info_new)

    # impropers
    impropers_info_new = []

    j = 0
    for i in range(len(lmp.improper_info)):
        if (lmp.improper_info[i, 2] in idx_select) and (lmp.improper_info[i, 3] in idx_select) and (lmp.improper_info[i, 4] in idx_select) and (lmp.improper_info[i, 5] in idx_select):
            j += 1
            impropers_info_new.append([j, lmp.improper_info[i, 1], mapping[mapping[:, 0] == lmp.improper_info[i, 2], 1][0], mapping[mapping[:, 0] == lmp.improper_info[i, 3], 1][0],
                                       mapping[mapping[:, 0] == lmp.improper_info[i, 4], 1][0], mapping[mapping[:, 0] == lmp.improper_info[i, 5], 1][0]])

    impropers_info_new = np.vstack(impropers_info_new)
    nimproper_type_new = len(mapping_dict['improper_coeff_new'])
    nimpropers_select = len(impropers_info_new)

    # file_template = './rxn2_post_v2.data_template'
    f = open('{}'.format(file_template), 'w')
    f.write('rxn2_post\n\n')
    f.write('{} atoms\n'.format(natoms_select))
    f.write('{} bonds\n'.format(nbonds_select))
    f.write('{} angles\n'.format(nangles_select))
    f.write('{} dihedrals\n'.format(ndihedrals_select))
    f.write('{} impropers\n'.format(nimpropers_select))
    f.write('\n')

    f.write('Types\n')
    f.write('\n')
    for i in range(len(atom_type_select)):
        f.write('{:.0f} {:.0f}\n'.format(atom_type_select[i, 0], atom_type_select[i, 1]))
    f.write('\n')

    f.write('Charges\n')
    f.write('\n')
    for i in range(len(charge_select)):
        f.write('{:.0f} {}\n'.format(charge_select[i, 0], charge_select[i, 1]))
    f.write('\n')

    f.write('Coords\n')
    f.write('\n')
    for i in range(natoms_select):
        f.write('{:.0f} {} {} {}\n'.format(
            coors_select[i, 0], coors_select[i, 1], coors_select[i, 2], coors_select[i, 3]))
    f.write('\n')

    f.write('Bonds\n')
    f.write('\n')
    for i in range(len(bond_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f}\n'.format(int(bond_info_new[i, 0]), int(bond_info_new[i, 1]),
                                                       int(bond_info_new[i, 2]), int(bond_info_new[i, 3])))
    f.write('\n')

    f.write('Angles\n')
    f.write('\n')
    for i in range(len(angle_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(angle_info_new[i, 0], angle_info_new[i, 1],
                                                              angle_info_new[i,
                                                                             2], angle_info_new[i, 3],
                                                              angle_info_new[i, 4]))
    f.write('\n')

    f.write('Dihedrals\n')
    f.write('\n')
    for i in range(len(dihedral_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(dihedral_info_new[i, 0], dihedral_info_new[i, 1],
                                                                     dihedral_info_new[i,
                                                                                       2], dihedral_info_new[i, 3],
                                                                     dihedral_info_new[i, 4], dihedral_info_new[i, 5]))
    f.write('\n')

    f.write('Impropers\n')
    f.write('\n')
    for i in range(len(impropers_info_new)):
        f.write('{:.0f} {:.0f} {:.0f} {:.0f} {:.0f} {:.0f}\n'.format(impropers_info_new[i, 0], impropers_info_new[i, 1],
                                                                     impropers_info_new[i,
                                                                                        2], impropers_info_new[i, 3],
                                                                     impropers_info_new[i, 4], impropers_info_new[i, 5]))
    f.write('\n')
    f.close()


def visualize_template(file_template, file_visual, element):

    f = open(file_template, 'r')
    L = f.readlines()
    f.close()

    for iline in range(len(L)):
        if 'atoms' in L[iline]:
            natoms = int(L[iline].split()[0])
        if 'bonds' in L[iline]:
            nbonds = int(L[iline].split()[0])
        if 'angles' in L[iline]:
            nangles = int(L[iline].split()[0])
        if 'dihedrals' in L[iline]:
            ndihedrals = int(L[iline].split()[0])
        if 'impropers' in L[iline]:
            nimpropers = int(L[iline].split()[0])
        if 'Types' in L[iline]:
            ltype = iline+2
            atom_type = np.empty(natoms)
            for ia in range(natoms):
                atom_type[ia] = int(L[ltype+ia].split()[1])

        if 'Coords' in L[iline]:
            lia = iline+2

        if 'Bonds' in L[iline]:
            lib = iline+2

    atom_info = pd.read_table(file_template, header=None, sep='\s+', skiprows=lia-1, nrows=natoms)

    box = np.eye(3)*40
    write_lammps_simple(file_visual,
                        box, int(np.max(atom_type)), natoms, np.zeros(
                            int(np.max(atom_type))), element,
                        np.zeros(int(np.max(atom_type))), np.array(atom_info.iloc[:, 0]),
                        atom_type, np.array(atom_info.iloc[:, 1:])-np.array([np.min(atom_info.iloc[:, 1:], axis=0)]))


def read_table_pot(file_name, key_words):
    """
    input: file_name, key_words
    output: r, e_pot, f_pot
    """
    r = []
    e_pot = []
    f_pot = []
    with open(file_name, 'r') as f:
        while True:
            line = f.readline()
            if key_words in line:
                meta_info = f.readline()
                f.readline()
                for i in range(int(meta_info.split()[1])):
                    line = f.readline()
                    data = line.split()
                    r.append(float(data[1]))
                    e_pot.append(float(data[2]))
                    f_pot.append(float(data[3]))
                break
    r = np.array(r)
    e_pot = np.array(e_pot)
    f_pot = np.array(f_pot)
    return r, e_pot, f_pot


def read_log_lammps(logfile, freq=1):
    """
    read the log file and return the list of dataframes
    parameters:
        logfile: str
            log file name
        freq: int
            frequency of the data to be read
    return:
        data_list: list
            list of dataframes
    """
    f = open(logfile, 'r')
    L = f.readlines()
    f.close()
    l1_list, l2_list = [], []
    for i in range(len(L)):
        if ('Step' in L[i]) and ('Temp' in L[i]):
            l1_list.append(i)
        if 'Loop time' in L[i]:
            l2_list.append(i)
    if len(l2_list) == 0:
        l2_list.append(len(L)-1)
    # print(l1_list, l2_list)
    data_list = []
    for i, l1 in enumerate(l1_list):
        l2 = l2_list[i]
        data = np.array(L[l1+1].split())
        for i in range(l1+1, l2, freq):
            data = np.vstack((data, L[i].split()))
        data = pd.DataFrame(data, dtype='float64', columns=L[l1].split())
        data_list.append(data)
    return data_list


def dump2str(save_file: str,
             dump_file: str,
             sample_file: str,
             idx: int or list):
    """
    convert the dump file to lammps structure file
    """
    lmp = read_lammps_full(sample_file)
    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]
    frame_list, t_list, L_list = read_lammps_dump_custom(dump_file)
    lmp_new = copy.copy(lmp)

    if type(idx) == int:
        idx = [idx]
    for id in idx:
        lmp_new.x = L_list[id][0]
        lmp_new.y = L_list[id][1]
        lmp_new.z = L_list[id][2]

        coors = frame_list[id].loc[:, ['x', 'y', 'z']].values
        lmp_new.atom_info[:, 4:7] = coors
        write_lammps_full(save_file + f'{id}', lmp_new)


def wrap_mol(save_file: str,
             input_file: str):
    """
    wrap the molecule in the box, make sure the atoms in the same mol are in the same image
    """

    lmp = read_lammps_full(input_file)
    lmp.atom_info = lmp.atom_info[np.argsort(lmp.atom_info[:, 0])]
    lmp_new = copy.copy(lmp)
    box_size = lmp.x[1] - lmp.x[0]  # assume cubic for now

    mol_id = lmp.atom_info[:, 1]
    mol_list = np.unique(mol_id)

    for mol in mol_list:
        idx = np.argwhere(mol_id == mol).flatten()
        coors = lmp.atom_info[idx, 4:7]
        rcoors = coors - coors[0]
        rcoors = rcoors - np.round(rcoors/box_size)*box_size
        coors = coors[0] + rcoors
        lmp_new.atom_info[idx, 4:7] = coors

    write_lammps_full(save_file, lmp_new)


def calculate_angle(v1, v2):
    """Calculate the angle between two vectors."""
    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    # convert to angle degree
    angle = np.arccos(cos_angle)/np.pi*180
    return angle


def angle_distribution(coors, box, cutoff):
    """
    compute O-O-O angle distribution in water within a cutoff distance
    inputs: coors, box, cutoff
    outputs: angles
    """
    n_atom = coors.shape[0]
    angles = []
    rcoors = np.dot(coors, np.linalg.inv(box))
    rdis = np.zeros([n_atom, n_atom, 3])
    for i in range(n_atom):
        tmp = rcoors[i]
        rdis[i, :, :] = tmp - rcoors
    rdis[rdis < -0.5] = rdis[rdis < -0.5] + 1
    rdis[rdis > 0.5] = rdis[rdis > 0.5] - 1
    a = np.dot(rdis[:, :, :], box)
    dis = np.sqrt((np.square(a[:, :, 0]) + np.square(a[:, :, 1]) + np.square(a[:, :, 2])))

    for i in range(n_atom):
        for j in np.arange(i+1, n_atom):
            for k in np.arange(j+1, n_atom):
                if dis[i, j] < cutoff and dis[i, k] < cutoff and dis[j, k] < cutoff:
                    angle = calculate_angle(a[j, i, :], a[k, i, :])
                    angles.append(angle)
                    angle = calculate_angle(a[i, j, :], a[k, j, :])
                    angles.append(angle)
                    angle = calculate_angle(a[i, k, :], a[j, k, :])
                    angles.append(angle)
    return angles

def compute_autocorrelation(forces, max_lag):
    """
    Compute the force autocorrelation function (FAF).

    Parameters:
    -----------
    forces : np.ndarray
        Array of shape (n_frames, n_atoms, 3), forces per atom.
    max_lag : int
        Maximum lag time (in frames) for computing the autocorrelation.

    Returns:
    --------
    faf : np.ndarray
        Force autocorrelation function as a 1D array of length max_lag.
    """
    n_frames, n_atoms, _ = forces.shape

    # Initialize autocorrelation array
    faf = np.zeros(max_lag)

    # Loop over lag times
    for lag in range(max_lag):
        # Compute dot product of forces separated by lag
        dot_products = np.sum(forces[:n_frames - lag] * forces[lag:], axis=(1, 2))
        faf[lag] = np.mean(dot_products)

    # Normalize by the zero-lag correlation
    faf /= faf[0]

    return faf

def compute_msd_pbc(positions, box_lengths, lag_array):
    """
    Compute mean-squared displacement (MSD) considering periodic boundary conditions.

    Parameters:
    -----------
    positions : np.ndarray
        Atom positions array of shape (n_frames, n_atoms, 3).
    box_lengths : np.ndarray or list
        Simulation box lengths of shape (n_frames, 3).
    lag_array : np.ndarray or list
        Array of lag times for which to compute the MSD.

    Returns:
    --------
    msd : np.ndarray
        Mean-squared displacement as 1D array of length max_lag.
    """
    n_frames, n_atoms, _ = positions.shape

    # Unwrap positions considering periodic boundary conditions
    unwrapped_pos = np.zeros_like(positions)
    unwrapped_pos[0] = positions[0]

    for t in range(1, n_frames):
        box_length_tmp = (box_lengths[t] + box_lengths[t - 1]) / 2
        delta = positions[t] - unwrapped_pos[t - 1]
        delta -= box_length_tmp * np.round(delta / box_length_tmp)
        unwrapped_pos[t] = unwrapped_pos[t - 1] + delta

    msd = np.zeros(len(lag_array))

    for i, lag in enumerate(lag_array):
        displacements = unwrapped_pos[lag:] - unwrapped_pos[:-lag]
        squared_displacements = np.sum(displacements**2, axis=2)
        msd[i] = np.mean(squared_displacements)

    return msd

def calc_compressibility(V, T=300):
    """
    Calculate compressibility from volume and temperature.
    :param V: Volume in nm^3
    :param T: Temperature in K
    :return: Compressibility in 1/Pa
    """
    kB = 1.380649e-23  # J/K
    V = V * 1e-27  # Convert from nm^3 to m^3
    kappa_T = np.var(V) / (V.mean() * kB * T)
    return kappa_T * 1e9 # to 1/GPa

def average_log(log_files, freq=1):
    """
    Average the log data from multiple files.
    Parameters:
        log_files: list of str
            List of log file names.
        freq: int
            Frequency of the data to be read.
    Returns:
        df_mean: pd.DataFrame
            DataFrame of mean values.
        df_std: pd.DataFrame
            DataFrame of standard deviation values.
    """
    dfs = []
    for i, log_file in enumerate(log_files):
        log = read_log_lammps(log_file, freq=freq)[-1]
        dfs.append(log)

    # Stack into a 3D array (frames  rows  columns)
    stacked = pd.concat(dfs, keys=range(len(dfs)))  # adds outer index (frame index)

    # Compute mean and std over the first level (i.e., over frames)
    df_mean = stacked.groupby(level=1).mean()
    df_std = stacked.groupby(level=1).std()
    return df_mean, df_std
